import pytest
import asyncio
import tempfile
import os
from typing import AsyncGenerator, Generator
from unittest.mock import AsyncMock, Mock
from datetime import datetime, timedelta

import httpx
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.pool import StaticPool

from main import app
from core.database import Base, get_db
from core.config import settings
from models.user import User
from models.match import Match
from models.task import Task
from models.chat import ChatMessage
from api.auth import get_current_user
from services.token_service import create_access_token

# Test database configuration
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"

@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def test_engine():
    """Create test database engine."""
    engine = create_async_engine(
        TEST_DATABASE_URL,
        poolclass=StaticPool,
        echo=False,
    )
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    yield engine
    
    await engine.dispose()

@pytest.fixture
async def test_session(test_engine) -> AsyncGenerator[AsyncSession, None]:
    """Create test database session."""
    async_session = async_sessionmaker(
        test_engine, class_=AsyncSession, expire_on_commit=False
    )
    
    async with async_session() as session:
        yield session
        await session.rollback()

@pytest.fixture
async def client(test_session) -> AsyncGenerator[httpx.AsyncClient, None]:
    """Create test client with database dependency override."""
    
    async def override_get_db():
        yield test_session
    
    app.dependency_overrides[get_db] = override_get_db
    
    async with httpx.AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
    
    app.dependency_overrides.clear()

@pytest.fixture
def test_user_data():
    """Test user data for registration."""
    return {
        "email": "test@example.com",
        "password": "testpassword123",
        "name": "Test User",
        "age": 25,
        "profession": "Software Engineer",
        "profile_text": "I love coding and hiking",
        "community": "Tech",
        "location": "San Francisco"
    }

@pytest.fixture
async def test_user(test_session) -> User:
    """Create a test user in the database."""
    user = User(
        email="test@example.com",
        hashed_password="$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4tbQJgqKqG",  # testpassword123
        name="Test User",
        age=25,
        profession="Software Engineer",
        profile_text="I love coding and hiking",
        community="Tech",
        location="San Francisco",
        coins=100,
        is_active=True,
        is_verified=True
    )
    
    test_session.add(user)
    await test_session.commit()
    await test_session.refresh(user)
    return user

@pytest.fixture
async def test_user2(test_session) -> User:
    """Create a second test user in the database."""
    user = User(
        email="test2@example.com",
        hashed_password="$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4tbQJgqKqG",  # testpassword123
        name="Test User 2",
        age=28,
        profession="Designer",
        profile_text="I enjoy art and music",
        community="Arts",
        location="New York",
        coins=50,
        is_active=True,
        is_verified=True
    )
    
    test_session.add(user)
    await test_session.commit()
    await test_session.refresh(user)
    return user

@pytest.fixture
async def authenticated_client(client, test_user) -> AsyncGenerator[httpx.AsyncClient, None]:
    """Create an authenticated test client."""
    # Create access token
    access_token = create_access_token(data={"sub": str(test_user.id)})
    
    # Add authorization header
    client.headers["Authorization"] = f"Bearer {access_token}"
    yield client

@pytest.fixture
async def authenticated_client2(client, test_user2) -> AsyncGenerator[httpx.AsyncClient, None]:
    """Create an authenticated test client for the second user."""
    # Create access token
    access_token = create_access_token(data={"sub": str(test_user2.id)})
    
    # Add authorization header
    client.headers["Authorization"] = f"Bearer {access_token}"
    yield client

@pytest.fixture
async def test_match(test_session, test_user, test_user2) -> Match:
    """Create a test match between two users."""
    match = Match(
        user1_id=test_user.id,
        user2_id=test_user2.id,
        status="active",
        created_at=datetime.utcnow(),
        expires_at=datetime.utcnow() + timedelta(days=2),
        coins_earned_user1=0,
        coins_earned_user2=0
    )
    
    test_session.add(match)
    await test_session.commit()
    await test_session.refresh(match)
    return match

@pytest.fixture
async def test_task(test_session, test_match) -> Task:
    """Create a test task for the match."""
    task = Task(
        title="Test Task",
        description="Test task description",
        task_type="bonding",
        difficulty="medium",
        category="bonding",
        match_id=test_match.id,
        base_coin_reward=10,
        difficulty_multiplier=2,
        final_coin_reward=20,
        ai_generated=True,
        created_at=datetime.utcnow(),
        expires_at=datetime.utcnow() + timedelta(days=1)
    )
    
    test_session.add(task)
    await test_session.commit()
    await test_session.refresh(task)
    return task

@pytest.fixture
def mock_ai_service():
    """Mock AI service for testing."""
    mock_service = Mock()
    mock_service.generate_task = AsyncMock(return_value=("Test Task", "Test description"))
    mock_service.is_available = Mock(return_value=True)
    return mock_service

@pytest.fixture
def mock_file_storage():
    """Mock file storage service for testing."""
    mock_storage = Mock()
    mock_storage.save_file = AsyncMock(return_value="test_profile.jpg")
    mock_storage.delete_file = AsyncMock(return_value=True)
    return mock_storage

@pytest.fixture
def temp_upload_dir():
    """Create temporary directory for file upload tests."""
    with tempfile.TemporaryDirectory() as temp_dir:
        yield temp_dir

@pytest.fixture
def test_image_file(temp_upload_dir):
    """Create a test image file for upload tests."""
    test_image_path = os.path.join(temp_upload_dir, "test_image.jpg")
    
    # Create a simple test image (1x1 pixel JPEG)
    with open(test_image_path, "wb") as f:
        f.write(b"\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0c\x14\r\x0c\x0b\x0b\x0c\x19\x12\x13\x0f\x14\x1d\x1a\x1f\x1e\x1d\x1a\x1c\x1c $.\x27 ,#\x1c\x1c(7),01444\x1f\x27=9=82<.342\xff\xc0\x00\x11\x08\x00\x01\x00\x01\x01\x01\x11\x00\x02\x11\x01\x03\x11\x01\xff\xc4\x00\x14\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xda\x00\x0c\x03\x01\x00\x02\x11\x03\x11\x00\x3f\x00\xaa\xff\xd9")
    
    return test_image_path

# Helper functions for common test operations
async def create_test_user(session: AsyncSession, **kwargs) -> User:
    """Helper function to create a test user with custom data."""
    default_data = {
        "email": f"test{datetime.utcnow().timestamp()}@example.com",
        "hashed_password": "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj4tbQJgqKqG",
        "name": "Test User",
        "age": 25,
        "profession": "Software Engineer",
        "profile_text": "I love coding and hiking",
        "community": "Tech",
        "location": "San Francisco",
        "coins": 100,
        "is_active": True,
        "is_verified": True
    }
    default_data.update(kwargs)
    
    user = User(**default_data)
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user

async def get_auth_headers(user_id: int) -> dict:
    """Helper function to get authentication headers for a user."""
    access_token = create_access_token(data={"sub": str(user_id)})
    return {"Authorization": f"Bearer {access_token}"}

def assert_response_success(response: httpx.Response, expected_status: int = 200):
    """Helper function to assert successful API response."""
    assert response.status_code == expected_status
    assert "application/json" in response.headers.get("content-type", "")

def assert_response_error(response: httpx.Response, expected_status: int, error_type: str = None):
    """Helper function to assert error API response."""
    assert response.status_code == expected_status
    if error_type:
        data = response.json()
        assert "detail" in data
        if isinstance(data["detail"], str):
            assert error_type.lower() in data["detail"].lower()
        elif isinstance(data["detail"], list):
            assert any(error_type.lower() in str(error).lower() for error in data["detail"])
